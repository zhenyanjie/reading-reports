### Reproduction for Distributed Systems using the Event Chaining Approach
使用事件链app完成分布式系统上的非侵入性故障重现

ABSTRACT 
在分布式系统上出现复杂的和不可预测的问题应该能够被诊断和复现，在一个development的环境里，让开发者可以找到真正的原因，和正确的解决办法。系统日志只有诊断信息，开发者重现错误需要手工猜测。这不可预测、浪费时间、并且可能会导致在修复时的服务中断。
本文提出了pensieve，一种能够从日志文件和系统字节码重建几乎最小的故障再现步骤的工具，而无需人为参与。现有的解决方案是通过符号执行找到导致错误的路径，Pensieve是基于部分跟踪观察（partial trace observation），它指出，程序员不会模拟整个执行来了解故障，而是按照控制和数据依赖关系的组合来重构一个简化的跟踪，只包含可能与失败相关的事件。Pensieve遵循一组精心设计的规则来推断导致故障症状的因果关系事件链，同时aggressively跳过不相关的代码路径，以避免符号执行模型的路径爆发开销。

INTRODUCTION
分布式系统不可避免地会遇到故障 - 无论是由于软件错误，人为错误（例如错误配置）还是硬件故障。 当故障发生时，供应商的首要任务是诊断，以便系统恢复。 2013年的研究表明，一半的软件开发时间用于调试

故障重现通常是后期调试中最关键的一步，也是彻底了解故障的前提条件。 许多最常用的调试技术，包括交互式调试器，“printf debugging”和增量调试都假设失败已被重现。证实解决方案也需要故障被重现。大型软件项目通常要求开发人员提供一个重现故障回归测试的测试案例。因此，故障恢复通常是后期调试的第一步和最后一步。先前的研究调查了466位开发人员，发现开发人员认为重现失败的步骤是bug报告中最有用的信息。

尽管重要，但是bug重现在后验测试中是最耗费时间的步骤。我们深入分析了分布式系统HDFS，HBase和ZooKeeper的30个随机抽样的错误报告的生命周期，发现开发人员花费大部分时间（69％）来重现故障。

分布式系统中的故障通常具有漫长而复杂的表现，涉及多个因果相关的用户输入事件。底层执行跨越具有复杂（通常是异步）通信机制的多线程组件。此外，由于性能和隐私问题，生产分布式系统仅记录有限的事后分析信息，通常以日志文件的形式。

现有工作有很多局限性：通过侵入性方法自动重现故障，如确定性重放[1,2,7,9,10,15,17,20,22]可以重播故障执行。 然而，他们在生产系统中的部署有限，因为供应商考虑到性能开销和对生产环境的影响。ESD 和SherLog 试图分别使用核心转储（coredumps）和日志文件作为证据来重现故障，并结合对程序代码的静态分析。两者都使用符号执行的变体[5]来搜索导致目标症状的执行路径。ESD将搜索引导到通过静态分析推断的中间目标，而SherLog将其分析限制在该程序的一部分。通常，通过符号执行推断的路径是精确的，并且包括沿着路径的每条指令。 然而，这种方法不能扩展到完全执行大型复杂系统，因为它需要在所有分支指令中分析分析，而不管它们与故障执行的相关性。

pensieve就比较厉害了，给由故障执行输出的日志文件，系统的字节码，支持的用户命令的列表以及与故障相关的症状的描述（通常是用户选择的日志文件中的错误消息子集），Pensieve输出序列 的用户命令，作为单元测试打包，可以可靠地再现故障。

pensieve的设计是基于partial trace observation：程序员几乎不会通过重构其完整的执行路径来调试故障; 相反，他们重点关注可能与故障有根本关系的指令，跳过绝大多数代码路径。

更具体地说，程序员通常在后处理调试过程中应用以下推理规则：
1. 可以通过搜索代码库找出合理的原因来解释故障事件。 例如，为了解释为什么变量具有特定的值，程序员通常会考虑它被定义在哪里，哪些可以在另一个线程甚至是组件中。 程序员直接从故障事件跳转到原因而不重建中间控制流程路径。
2. 当有多个可能的事件解释时，日志打印语句提供了一个有用的线索。 例如，当可以在多个程序位置定义变量值时，程序员通常会检查日志是否在其中一个位置附近打印
3. 对于许多循环，只有它们的迭代的一个子集具有对于失败发生所必需的效果。 模拟整个循环（通过符号执行完成）通常与调试无关。

基于这些观察，Pensieve实现了event chaining，静态分析策略与以前的方法大不相同。Pensieve产生了一个部分追踪，描述在故障执行中发生的一组事件。它通过迭代地分析最有可能与故障相关的控制和数据依赖关系，直到分析到达外部API调用（用户命令），同时丢弃可能无关的依赖关系，并且积极地跳过剩余的代码路径。所产生的一组API调用用于生成单元测试。 Pensieve全局的搜索代码库寻找原因，模拟程序员试图了解故障所使用的“跳跃”策略。例如，Pensieve找到感兴趣的变量被修改的位置，但不会验证连接修改和使用点的控制流程路径的存在。 这通常允许Pensieve绕过复杂的网络传输代码，并发现在另一个线程或组件中发生的根本原因，因为分布式系统的编码实践倾向于在网络通信的两端使用统一的对象类型

推测一个捕获动态执行信息的依赖关系跟踪需要Pensieve来区分相同方法的不同调用和循环的不同迭代。 Pensieve通过为推断的事件分配符号调用和迭代ID来解决这个问题。 当存在多个替代性依赖性时，Pensieve很大程度上依赖于日志打印语句作为线索来选择哪一个更可能发生。 最后，它将每个循环的依赖性归因于因果路径。 对于大多数循环，它只需要分析一次迭代。

Pensieve积极跳过代码路径不可避免地牺牲了准确性，并且可能导致一些不可行或不准确的依赖。 我们通过动态验证阶段纠正不准确之处，提供反馈来完善Pensieve的分析。 由Pensieve生成的单元测试在受控JVM中执行，该JVM观察推断的依赖关系及其部分顺序是否得到遵守。 如果不是，Pensieve识别出发散点，确定避免分歧的条件，并以此条件作为附加条件重新启动静态分析阶段

Pensieve具有以下属性：
1. 可扩展到实际分布式系统。 Pensieve的可扩展性不受代码大小或执行路径数量的限制，而是由因果依赖事件的数量（其数量级更小）限制，允许它在复杂的分布式系统代码库上进行扩展。
2. 重现非确定性的失败。 Pensieve的分析捕获了多个线程或进程之间的数据依赖关系，动态验证阶段强制执行时序约束以可靠地再现故障
3. 简化再现步骤。 Pensieve的设计选择性地推断出最重要的因果依赖关系导致了生产步骤的几乎最小的顺序，因为它只是为了满足最重要的条件。

我们对报告给HDFS，HBase，Cassandra和ZooKeeper的18个随机抽样实际故障评估Pensieve。 Pensieve可以自动复制13个（72％），并提供两个有用的部分诊断，为整体的83％的故障提供有用的结果。 从故障症状到用户命令的事件链由平均105个事件组成，与实施SherLog算法的路径约束大小相比，数量级更小（SMT解算器使用的数千万个AST节点 表示路径条件）实际故障执行路径的复杂性数量级也更小（数千万条分支指令）

本文作出以下贡献。 首先，我们提出一种使用“部分跟踪观察”重构故障执行的简化部分跟踪的算法，事件链接。 其次，使用这种算法，我们构建了第一个能够从复杂生产分布式系统非侵入式复制故障的Pensieve工具。 最后，我们提出一个简单的动态细化机制来验证和优化生成的再现步骤

Pensieve也有以下限制。 一是分析不健全，不完整; 动态细化阶段旨在纠正这种不准确之处。 此外，必须可以使用简单的API调用来执行系统的功能，并使用系统输出的错误日志消息或堆栈跟踪的子集来表征故障。 这些限制在第6节详细讨论


备注：通常情况下coredmp包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。可以理解为把程序工作的当前状态存储成一个文件。许多程序和操作系统出错时会自动生成一个core文件。

字节码（Byte-code）是一种包含执行程序、由一序列 op 代码/数据对组成的二进制文件。字节码是一种中间码，它比机器码更抽象。它经常被看作是包含一个执行程序的二进制文件，更像一个对象模型