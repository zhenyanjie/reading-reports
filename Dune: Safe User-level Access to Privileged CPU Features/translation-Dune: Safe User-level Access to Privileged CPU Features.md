### Dune:安全用户级访问特权cpu功能

#### Abstract

dune 是一个系统，为应用程序提供直接但是安全的访问硬件功能，比如环保护，页表和标记TLB，同时保留现有的操作系统面向进程的接口。 Dune使用现代处理器中的虚拟化硬件来提供一个过程，而不是一个机器抽象。它包括初始化虚拟化硬件和调解与内核的交互的小内核模块，以及帮助应用程序管理特权硬件功能的用户级库。我们将介绍在64位x86的linux上实现的Dune。 我们使用Dune来实现三个用户级应用程序，这些应用程序可以从访问特权硬件中受益：一个用于不受信任代码的沙箱，一个特权分离工具和一个垃圾回收器。 使用Dune可以大大简化这些应用的实现，并提供显着的性能优势。

#### 1 Introduction 

各种应用程序都可以受益于访问“仅内核”硬件功能。（//什么意思，什么叫kernel-only hardware features  是不是指只有内核可以访问的硬件功能） 一个例子：Azul系统通过使用分页硬件展示垃圾收集的显著加速。 另一个例子：过程迁移（process migration）虽然可以用用户程序实现，但可以通过直接访问页错误和系统调用获得显著的受益。在某些情况下，甚至可能完全替换内核以满足特定应用程序的需要。 例如，IBOS通过将浏览器抽象移动到最低的OS层来提高浏览器的安全性。

这种系统需要在内核中进行改变，因为用户空间中的硬件访问由于安全和隔离原因而受到限制。 不幸的是，修改内核在实践中是不理想的，因为内核更改可能被侵入，如果做不正确，会影响整个系统的稳定性。 此外，如果多个应用程序需要内核更改，则不能保证更改能够组合在一起。

另一个策略是将应用程序捆绑到具有专用内核的虚拟机映像中（//我猜是这个虚拟机只虚拟需要的硬件，类似一个专用计算机）。 许多现代CPU包含虚拟化硬件，客户操作系统可以安全高效地访问内核硬件功能。 此外，虚拟机提供类似于进程的故障控制，即，bug或恶意行为不应该使整个物理机器失效。

不幸的是，虚拟机与主机操作系统的集成很差。 进程期望从其父进程继承文件描述符，产生其他进程，与其父进程和子进程共享文件系统和设备，并使用IPC服务（如Unix域套接字）。 例如，为了加速垃圾收集的目的，将进程移动到虚拟机可能会破坏许多假设，并且可能根本不值得麻烦。 此外，为应用程序特定的虚拟机生成内核不是小任务。 生产内核（如Linux）很复杂，很难修改。 然而，实现具有简单虚拟存储器层的专用内核也是具有挑战性的。 除了虚拟内存之外，必须支持文件系统，网络堆栈，设备驱动程序和引导过程。

**上文梗概：各种程序都可以受益于访问kernel-only 的 硬件功能，可以通过修改内核和将应用程序捆绑到具有专用内核的虚拟机映像中这两种方法实现，但是都有一些问题**

本文介绍了一种应用程序使用内核硬件特性的新方法：使用虚拟化硬件提供一个过程，而不是一个机器抽象。 我们在称为Dune的系统中的64位Intel CPU上为Linux实现了这种方法。 Dune提供了一个可加载的内核模块，可以与未修改的Linux内核一起工作。 该模块允许进程进入“Dune模式”，这是一种不可逆的转换，通过虚拟化硬件启用对特权硬件功能的安全和快速访问，包括特权模式，虚拟内存寄存器，页表和中断，异常和系统调用向量。 我们提供了一个用户级库libDune，以方便这些功能的使用。

对于适合其范例的应用程序，Dune提供了优于虚拟机的几个优点。 首先，Dune进程是一个普通的Linux进程，唯一的区别是它使用VMCALL指令调用系统调用。 这意味着Dune进程可以完全访问系统的其余部分，并且是其中不可或缺的一部分，而且Dune应用程序易于开发（如应用程序编程，而不是内核编程）。 第二，因为Dune内核模块不试图提供机器抽象，所以模块可以更简单和更快。 特别地，虚拟化硬件可以被配置为避免保存和恢复虚拟机所需的若干硬件状态。

关于dune，我们致力于以下几个方面：

- 我们提出一个设计，使用硬件辅助虚拟化安全和高效地暴露特权硬件功能到用户程序，同时保留标准的OS抽象
- 我们详细评估了三个硬件特性，并展示了它们如何对用户程序有所帮助：异常，分页和特权模式。
- 我们通过实现和评估三种用例来演示Dune的端到端实用程序：沙盒，特权分离和垃圾收集。

#### 2 虚拟化和硬件 

在本节中，我们回顾了虚拟化的硬件支持，并讨论了Dune能够公开的特权硬件功能。 在整篇论文中，我们以x86 CPU和Intel VT-x来描述Dune。 然而，这不是我们的设计的根本，在第7节，我们扩大我们的讨论，以包括将来支持的其他架构

##### 2.1 The Intel VT-x Extension

为了提高虚拟化性能和简化VMM实现，英特尔开发了VT-x，一种x86 ISA的虚拟化扩展。 AMD还提供了类似拓展，是一个叫做SVM的不同硬件接口。

使硬件适应以支持虚拟化的最简单的方法是引入用于捕获每个访问特权状态的指令的机制，使得可以由VMM执行仿真。 VT-x包含一个更复杂的方法，受IBM解释执行架构的启发，其中尽可能多的指令，包括大多数访问特权状态，直接在硬件中执行，而没有来自VMM的任何干预。 这是可能的，因为硬件维持特权状态的“卷影副本”。 这种方法的动机是提高性能，因为陷阱可能是一个重要的开销来源。

VT-x采用一种设计，其中CPU分为两种操作模式：VMX root和VMX非root模式.VMX root模式通常用于运行VMM并且不改变CPU行为，除了允许访问用于管理VT-x的新指令。 另一方面，VMX非root模式限制CPU行为，并且用于运行虚拟客户机操作系统.

VMX模式之间的转换由硬件管理。 当VMM执行VMLAUNCH或VMRESUME指令时，硬件执行VM条目;将CPU置于VMX非root模式并执行guest虚拟机。 然后，当需要从VMM进行操作时，硬件执行VM退出，将CPU置回VMX root模式并跳转到VMM入口点。 硬件自动并在两种类型的转换期间恢复大多数体系结构状态。 这通过在称为VM控制结构（VMCS）的存储器驻留数据结构中使用缓冲器来实现.

除了存储架构状态之外，VMCS还包含大量配置参数，允许VMM控制执行并指定应该生成VM退出事件的类型。 这给予VMM在确定哪些硬件暴露给客户端方面相当大的灵活性。 例如，VMM可以配置VMCS，使得HLT指令导致VM退出，或者其可以允许客户机停止CPU。 但是，某些硬件接口（例如中断描述符表（IDT）和特权模式）在VMX非root模式下隐式显示，并且在访问时不会生成VM退出。 此外，访客可以通过使用VMCALL指令手动请求VM退出。

虚拟内存可能是VMM安全暴露的最困难的硬件功能。 一个草人解决方案是配置VMCS，以便客户可以访问页表根寄存器％CR3。 然而，这要完全信任客户机，因为它可以配置页表以访问任何物理页，包括属于vmm的内存，幸运的是，vt-x具备专用硬件机制，称为扩展页表（EPT），可以强制在直接访问虚拟内存的guest虚拟机上实现内存隔离。 它只能使用由VMM配置的第二，底层的地址转换。 AMD的SVM包括与EPT类似的机制，称为嵌套页表（NPT）

**上文梗概：虚拟化的硬件支持 是 intel的VT-x VT-x采用一种设计，将cpu分为root和非root两种模式，非root模式限制cpu行为 VMCS用于存储架构状态，包含大量配置参数，给予vmm在确定那些硬件暴露给客户端方面比较大的灵活性  虚拟内存是一个难点，EPT可以解决**

##### 2.2 支持硬件功能 

Dune使用VT-x为用户程序提供对x86保护硬件的完全访问。 这包括三个特权硬件功能：异常，虚拟内存和特权模式。 表1显示了可用于每个功能的相应特权指令。 Dune还公开了分段，但我们不进一步讨论它，因为它主要是现代x86 CPU的遗留机制

在例如仿真，调试和性能跟踪的各种使用情况中，对异常的有效支持很重要。 通常，向用户程序报告异常需要特权模式转换和上调机制（例如，信号）。 Dune可以减少异常开销，因为它使用VT-x直接在硬件中传递异常。 但是，这不允许Dune进程独占CPU，因为定时器中断和其他意在用于内核的异常仍将导致VM退出。 最终结果是消除了软件开销，并且异常性能仅由硬件效率确定。 仅举一个例子，与Linux中的SIGSEGV相比，Dune提高了页面错误异常的速度4倍以上。 还加速了其他几种类型的异常，包括断点，浮点溢出和下溢，除以零和无效操作码。

用户程序也可以受益于快速和灵活地访问虚拟内存。 用例包括检查点，垃圾收集（在本文中评估），数据压缩分页和分布式共享内存。 Dune通过将页表条目直接暴露给用户程序来改进虚拟内存访问，允许他们使用简单的内存引用控制地址转换，访问权限，全局位和修改/访问位。 相比之下，即使最高效的操作系统接口也需要系统调用来增加额外的延迟，以便执行这些操作。 让应用程序编写自己的页表不会影响安全性，因为底层EPT只暴露正常的进程地址空间，与不使用dune访问一样。

Dune还为用户程序提供手动控制TLB无效的能力。 因此，当应用程序允许时，页表更新可以批量执行。 这在内核中支持相当困难，因为当必须维持一般正确性时难以推迟TLB无效。此外，Dune通过提供对英特尔最近添加的过程上下文标识符（PCID）特征的访问来暴露TLB标记。 这允许单个用户程序有效地在多个页表之间切换。 总而言之，我们表明，使用Dune在Appel和Li用户级虚拟内存基准测试中，结果是Linux的7倍速加速。 该图包括使用异常硬件来减少页错误等待时间

最后，Dune展示对特权模式的访问。 在x86上，最重要的权限模式是环0（管理员模式）和环3（用户模式），但环1和环2也可用。 两种特权模式的motivating用例是特权分离和不可信代码的沙盒，在本文中都进行了评估。 Dune可以有效地支持特权模式，因为VMX非root模式维护其自己的一组特权环。 因此，Dune允许进程内的硬件强制保护以内核保护自己免受用户进程的影响。 页表中的管理程序位（supervisor 位）可用于控制存储器隔离。 此外，系统调用指令陷阱到进程本身，而不是内核，其可以用于系统调用插入，并且防止不可信代码直接访问内核。 与Linux中的ptrace相比，我们表明Dune拦截一个系统调用可减少25倍的开销。

虽然Dune所展示的硬件功能足以支持我们的激励用例(motivating use cases)，但是其他一些硬件功能（例如高速缓存控制，调试寄存器和对DMA能力的设备的访问）也可以通过虚拟化硬件安全地暴露(expose)。 我们留下这些作为未来的工作并且将在第七部分讨论他们的潜力。

**上文梗概： Dune支持的三种硬件功能：异常 虚拟内存 特权指令，使用dune 比不使用的性能有显著提高**

#### 3 Dune的内核支持

Dune的核心是一个内核模块，管理VT-x和向用户程序提供对特权的硬件功能的访问。我们这里描述的这个模型，包括一个系统概述，威胁模型，和一个与普通vmm的比较。然后，我们探索模块的运行的三个关键方面：内存管理，expose对特权硬件的访问，保留对内核接口的访问。最后，我们描述了基于linux内核的Dune模块

##### 3.1 系统概述

图1显示了Dune架构的高层次图。Dune通过一个使能了VT-x的模块来拓展内核，把内核放置在VMX root模式。进程使用Dune是在VMX 非root模式下，被授予直接但是安全的对特权硬件的访问。Dune模块拦截VM退出，这是Dune进程访问内核的唯一方法，并执行任何必要的操作，例如服务页面错误，调用系统调用或在HLT指令后释放CPU。所Dune还包括一个称为libDune的库，以帮助管理用户空间中的特权硬件功能，第4节进一步讨论。

我们选择性地将Dune应用于需要它的进程，不使用Dune的进程完全不受影响。进程可以通过启动/ dev / dune设备上的ioctl的转换在任何点启用Dune，但是一旦进入Dune模式，进程不能退出Dune模式。每当Dune进程fork时，子进程不会在Dune模式下启动，但如果用例需要，可以重新进入Dune。

Dune模块需要VT-X。其结果是，它不能被一个虚拟机内使用的，除非有嵌套的VT-X的支持;这种配置的性能特性是未来考虑的一个有趣的话题。另一方面，即使VMM需要VT-x，也可以在与Dune模块相同的机器上运行VMM，因为可以在每个核上独立地控制VT-x

##### 3.2 Threat Model //威胁模型？

Dune暴露出特权CPU的功能，而不会影响底层操作系统的现有安全模型。可以在不通过dune同一系列的系统调用产生通过启用dune过程中产生的任何外部影响。然而，通过暴露硬件特权模式下，dune启用一个processthat中的其他特权分离技术否则将不实际的。

我们假设CPU没有缺陷，尽管我们承认在极少数情况下已经发现可利用的硬件缺陷。

##### 3.3 与vmm比较

尽管所有使用VT-x的软件有共同的结构，但是Dune对VT-x的使用偏离了标准VMM的使用。具体来说，Dune暴露了一个进程环境，而不是机器环境。因此，Dune不能支持正常的客户操作系统，但这允许Dune更轻，更灵活。 一些最显着的差异如下：

- 超级调用（Hypercall）是VMM支持半虚拟化的常用方法，其中客户机操作系统被修改为使用更高效且难以虚拟化的接口。相比之下，在Dune中，hypercall机制调用正常的Linux系统调用。例如，VMM可以提供超级调用来为虚拟网络设备注册中断处理程序，而Dune进程将使用超级调用来在TCP套接字上调用读取。
- 许多VMM模拟物理硬件接口，以支持未修改的客户操作系统。在Dune中，只有可以在没有VMM干预的情况下直接访问的硬件功能可用; 在这种情况下，Dune进程落回到操作系统是不可能的。例如，大多数VMM花费很大的时间来呈现虚拟图形卡接口以便支持帧缓冲器。相比之下，Dune进程采用正常的OS显示服务，通常是通过Unix域套接字和共享内存访问的X服务器。
- 典型的VMM必须保存和恢复支持客户机操作系统所需的所有状态。在Dune中，我们可以限制客户和主机状态的差异，因为使用Dune的进程具有较窄的硬件接口。这导致减少执行VM条目和VM退出的开销。
- VMM将每个VM放置在模拟平面物理内存的单独地址空间中。在Dune中，我们配置EPT以反映进程地址空间，结果，当两个进程映射存储器段时，存储器布局可以是稀疏的，并且可以相干地共享存储器。

尽管有这些差异，Dune模块可以被认为是一个type-2 管理程序，因为它运行在现有操作系统内核的顶部。

##### 3.4 内存管理

内存管理的dune模块最大的责任之一。面临的挑战是直接页面表访问用户程序，同时防止任意访问物理内存。此外，我们的目标是默认提供一个正常的进程内存地址空间，允许用户程序只添加他们需要的功能，而不是完全替换内核级内存管理。

分页转换（paging translations）在Dune中的三种不同情况下进行，如图2所示。在虚拟化术语中，这是主机 - 虚拟到主机 - 物理（即原始存储器）转换。主机 - 虚拟地址是普通虚拟地址，但它们仅由内核和正常进程使用。 对于使用Dune的进程，用户控制的页表将客户虚拟地址映射到客户物理地址。然后，由内核管理的EPT执行从客机物理到主机 - 物理的附加转换。 由使用Dune的进程创建的所有内存引用只能是客户虚拟，允许在EPT中强制实施隔离和正确性，而应用程序特定的功能和优化可以应用于用户页表。

理想情况下，我们希望将EPT与内核的页表尽可能匹配，因为我们的目标是使用Dune访问与正常进程相同的地址空间。如果它被硬件允许，我们只需将EPT和内核的页表指向同一个页根。不幸的是，两个限制使这不可能。 首先，EPT需要与标准x86页表不同的二进制格式。 第二，Intel x86处理器将客户 - 物理地址的地址宽度限制为与主机 - 物理地址相同。在标准虚拟机环境中，这不会是一个问题，因为任何被仿真的机器都将具有实际上有限的RAM量。然而，对于Dune，问题是我们想要暴露完整的主机 - 虚拟地址空间，而客户 - 物理地址空间被限制为较小的大小（例如，36位物理限制相对于48位虚拟 限制在许多当代英特尔处理器）。我们注意到，在32位保护模式下运行时，不会出现此问题，因为物理地址至少与虚拟地址一样大

我们对EPT格式不兼容的解决方案是查询内核的进程内存映射，并手动更新EPT以反映它们。我们从一个空的EPT开始。 然后，每次访问丢失的EPT条目时，我们都会收到一个EPT故障（一种类型的VM退出）。 故障处理器制作一个新的EPT条目，反映由内核的页错误处理程序报告的地址转换和许可。有时，地址范围需要取消映射。 此外，内核需要页面访问来辅助交换和页面脏状态，以确定何时需要回写到磁盘。Dune通过挂钩到MMU通知程序链中来支持所有这些情况，KVM使用的方法相同。例如，当地址未映射时，Dune模块接收事件。 然后它驱逐受影响的EPT条目并在适当的Linux页面结构中设置脏位。

我们通过仅允许在EPT中映射一些地址范围来解决地址宽度问题。具体来说，我们只允许从进程的开始（即堆，代码和数据段），mmap区域和堆栈的地址。目前，我们将这些区域限制为4GB，允许我们压缩地址空间以适应EPT的前12GB。通常，用户的页表将地址扩展为其原始布局。这可能导致使用地址空间的非标准部分的程序不兼容，尽管这种情况很少见。更复杂的解决方案可以以任意顺序将每个虚拟存储器区域包装到客户 - 物理地址空间中，然后向用户程序提供将该段重新映射到其自己的页表中的正确客户 - 虚拟地址所需的附加信息，从而避免 不可寻址存储器区域的可能性。

##### 3.5 暴露访问硬件

如前所述，Dune暴露了对异常，虚拟内存和权限模式的访问。 异常和特权模式在VMX非root模式下是隐式可用的，不需要任何特殊配置。另一方面，虚拟内存需要访问％CR3寄存器，这可以在VMCS中授予。 我们为每个进程维护单独的VMCS，以允许每进程配置特权状态并且更容易和有效地支持上下文切换

x86包括确定启用哪些硬件特征（例如，浮点，SSE，无执行等）的各种控制寄存器，虽然我们可以允许Dune进程直接配置这些，但是我们改为镜像由内核设置的配置。这使我们能够支持正常的过程环境; 允许许多配置更改将破坏与用户程序的兼容性。例如，对于64位进程禁用长模式没有什么意义。 然而，这个规则有几个重要的例外。首先，我们允许用户程序禁用分页，因为它是x86上唯一可用于清除全局TLB条目的方法。其次，我们为用户程序提供对浮点硬件的一些控制，以允许支持延迟浮点状态管理。

在某些情况下，由于性能原因，Dune限制对硬件寄存器的访问。例如，Dune不允许修改MSR，以避免在每次系统调用期间保存和恢复它们的相对较高的开销。FS和GS基址寄存器是异常，因为它们不仅频繁使用，而且还由硬件自动保存和恢复。MSR LSTAR包含系统调用处理程序的地址，是一种特殊情况，其中Dune允许只读访问。这允许用户进程在现有地址处映射用于系统调用处理程序的代码（通过操纵其页表），而不是将寄存器改变为新地址，并且结果是损害性能.

Dune暴露对时间戳计数器（TSC）的原始访问。相比之下，大多数VMM虚拟化TSC以便避免混淆客户内核，如果使在VMM中花费的时间可见，则倾向于使得定时假设可能被违反。

##### 3.6 保留os接口

除了暴露特权硬件功能之外，Dune还保留对OS系统调用的访问。正常的系统调用调用指令只会在进程本身内捕获，并且不会导致VM退出。 相反，进程必须使用VMCALL（超级调用指令）来进行系统调用。Dune模块通过内核的系统调用表对超级调用进行向量。 在某些情况下，它必须在调用系统调用处理程序之前执行额外的操作。 例如，在退出系统调用期间，Dune执行清除任务。

Dune完全改变了如何调用信号处理程序。 一些信号通过更有效的直接硬件支持来消除。例如，硬件页错误大多包含SIGSEGV的作用。 对于其他信号（例如，SIGINT），Dune模块向进程中注入伪硬件中断。这不仅是一种有效的机制，而且还具有正确构成权限模式的优点。例如，如果用户进程正在环3中运行到沙箱不受信任的代码，硬件将自动将其转换到环0，以便安全地服务信号。

##### 3.7 实现  Implementation

Dune目前支持在64位长模式下在Intel x86处理器上运行的Linux。支持AMD CPU和32位模式是未来可能的增加。为了保持对内核的更改尽可能不干扰，我们开发了Dune作为动态可加载的内核模块。我们的实现部分基于KVM。 具体来说，它共享用于管理低级VT-x操作的代码。但是，高级代码不与KVM共享，因为Dune与VMM操作不同。 此外，我们的Dune模块比KVM简单，只包含2,509行代码。

。。。

#### 4 用户模式环境

使用Dune的进程的执行环境与正常进程有一些差异。由于特权环是暴露的硬件功能，一个区别是用户代码在环0中运行。尽管改变了某些指令的行为，但这通常不会导致现有代码的任何不兼容性。环3也是可用的并且可以可选地用于限制不受信任的代码。另一个区别是系统调用必须作为超级调用执行。为了简化支持这种变化，我们提供了一种机制，可以检测何时从环0执行系统调用，并自动将其作为超级调用重定向到内核。 这是libDune中包含的许多功能之一。

libDune是一个库，使构建使用dune的应用程序更加简单。它完全不受内核的信任，并由一组实用程序组成，有助于管理和配置特权硬件功能。libDune的主要组件包括页表管理器，ELF加载器，简单的页面分配器和帮助用户程序管理异常和系统调用的例程。 libDune目前有5,898行代码。

因此，我们提供给可选的libc的修改后的版本做了使用，以获得稍许的性能优势VMCALL指令，而不是SYSCALL指令。

##### 4.1 引导

在许多方面，将进程转换到Dune模式类似于引导操作系统。 第一个问题是，在启用Dune之前必须提供有效的页表。简单的标识映射是不够的，因为虽然目标是在转换之前和之后使处理地址保持一致，但是必须考虑EPT的压缩布局。创建页表后，将以页表根为参数调用Dune条目ioctl。然后，Dune模块将进程切换到Dune模式并开始执行代码，使用提供的页表根作为初始％CR3。从那里，libDune配置特权寄存器来设置合理的操作环境。例如，它加载GDT以提供基本的平面分割并加载IDT，以便捕获硬件异常。它还在TSS中设置单独的堆栈来处理双重故障并配置GS段基址，以便轻松访问每个线程的数据。

##### 4.2 限制

虽然我们能够运行各种各样的Linux程序，libDune仍然缺少一些功能。首先，我们没有完全集成对信号的支持，尽管事实上它们由Dune模块报告。 应用程序需要使用dune信号，而更兼容的解决方案将覆盖几个libc符号，如信号和sigaction。第二，虽然我们支持pthread，但libDune中的一些实用程序（如页表管理）还不是线程安全的。 这两个问题都可以通过进一步实施来解决。

在Dune环境中工作的一个意想不到的挑战是，系统调用参数必须是有效的主机 - 虚拟地址，而不管如何设置客户 - 虚拟映射。在许多方面，这与向执行DMA的硬件设备提供物理地址的需要相平行。在大多数情况下，我们可以通过让guest虚拟地址空间镜像主机 - 虚拟地址空间来解决这个问题。对于不可能的情况，必须走用户页表以调整系统调用参数地址。

Dune引入的另一个挑战是，通过暴露对特权硬件的更大访问权限，用户程序需要更多的特定于体系结构的代码，从而潜在地降低了可移植性。libDune目前提供了一个以x86为中心的API，因此它已经与AMD机器兼容。然而，应该可以修改libDune来以与许多OS内核的构造并行的方式支持非x86体系结构。这将需要libDune提供一个高效的架构独立接口，这个主题值得在未来的版本中探索。

#### 5 应用

Dune是通用的，它可以让我们改进广泛的应用程序。我们构建了两个与安全相关的应用程序，一个沙箱和特权分离系统，以及一个与性能相关的应用程序，一个垃圾回收器。我们的目标是更简单的实施，更高的性能，并在适用的情况下，提高安全性。

##### 5.1 沙盒

沙盒是限制代码的过程，以限制它可以访问的内存和它可以使用的接口或系统调用。它对于各种目的是有用的，例如在Web浏览器中运行本地代码，创建安全的操作系统容器，以及保护移动电话应用程序。为了探索Dune这些类型的应用程序的潜力，我们构建了一个沙箱，支持本地64位Linux可执行文件。

##### 5.2 wedge

Wedge是一种特权分离系统。 它的核心抽象是一个sthread，它提供类似pthread的性能的叉状隔离。 sthread是一个轻量级进程，可以访问策略指定的内存，文件描述符和系统调用。这个想法是在一个线程中运行有风险的代码，以便其中包含任何漏洞。例如，在Web服务器中，每个客户端请求将在单独的线程中运行，以保证用户之间的隔离。为了使其可行，sthread需要快速创建（例如，每个请求一个）和上下文切换时间。快速创建可以通过sthread回收实现。 sthread不是每次都创建和杀死sthread，而是在其第一次创建时检查点（同时仍然是原始的和未开发的），并在退出时恢复，以便在下一个创建请求时安全地重用它。这样做将线程创建成本降低到（更便宜的）恢复内存的成本。

Wedge使用了许多Dune的硬件功能。环保护用于强制执行系统调用策略; 页表限制了什么内存sthreads可以访问; 脏位用于在sthread回收期间恢复存储器; 并且标记的TLB用于快速上下文切换。

##### 5.3 垃圾回收

垃圾收集器（GC）经常利用存储器管理硬件来加速收集。Appel和Li解释了使用标准用户级虚拟内存保护操作的几种技术，而Azul系统在修改内核和系统调用接口的范围内。相比之下，Dune提供了一种干净和高效的方式直接访问相关的硬件。 Dune提供的垃圾收集器感兴趣的功能包括：fast faults，dirty bits ，page table ，TLB control

#### 6 评测

在本节中，我们评估Dune的性能和实用性。虽然使用VT-x具有内在成本，但在大多数情况下，Dune的开销相对较小。另一方面，Dune为可以利用访问特权硬件功能的应用程序提供了显着的机会来提高安全性和性能。

所有测试均在采用Intel Xeon E3-1230 v2（四核Ivy Bridge CPU时钟为3.3 GHz）和16GB RAM的单插槽计算机上执行。我们安装了最新的64位版本的Debian Linux，其中包括Linux内核版本3.2。 电源管理功能（例如频率缩放）已禁用。

##### 6.1 Overhead from Running in Dune 

Dune的性能受到两个主要开销来源的影响。首先，VT-x增加了进入和退出内核-VM条目的成本，并且VM出口比快速系统调用指令或异常更昂贵。结果，系统调用和其他类型的故障（例如，页错误）必须在Dune中支付固定成本。第二，使用EPT使得TLB错过更昂贵，因为在一些情况下，hardware page walker 必须遍历两个页表而不是一个页表。

我们建立综合基准测量这两种效应。表2显示了系统调用，页面故障和页表走访的开销。对于系统调用，我们手动执行getpid，基本上为空的系统调用（Dune的最坏情况），并测量往返延迟。对于页面故障，我们测量了内核在预先归零的内存页中发生故障所需的时间。 最后，对于页表行走，我们测量了填充TLB未命中所花费的时间。

测量TLB未命中开销需要我们构建一个简单的内存压力工具。它通过在2^16个内存页面上执行随机页面对齐步骤来工作。这模拟了具有差的存储器局部性的工作负载，因为几乎每个存储器访问都导致最后一级TLB未命中。然后，我们将等待页表遍历的总周期数（由性能计数器报告）除以内存引用的总数，得到每页走查的周期成本。

一般来说，Dune开销增加对端到端性能的影响很小，如第6.3节所示。对于系统调用，在内核中花费的时间往往是比固定的VMX模式转换成本更大的成本。页面故障开销也不是很关注，因为页面故障在正常使用期间往往不经常发生，并且当需要更高的性能时，可以直接访问异常硬件。另一方面，Dune使用EPT确实会影响某些工作负载的性能。对于具有良好内存局部性或小工作集的应用程序，它没有影响，因为TLB命中率足够高。然而，对于具有差的存储器局部性或大的工作集的应用，更频繁的TLB未命中导致可测量的减速。限制这种开销的一个有效策略是使用大页面。 我们在6.3.1节进一步探讨这种可能性。

##### 6.2 通过Dune 可能实现的优化

访问特权硬件功能创造了许多优化的机会。 表3显示了在以下操作系统工作负载中实现的加速：

- ptrace是系统调用插值性能的度量。
- trap表明它需要一个过程的时间去故障异常的页面
- appel1是用户级的虚拟内存管理性能的衡量标准
- appel2是用户级的虚拟内存管理性能的另一个措施

##### 6.3 应用程序性能

###### 6.3.1 沙盒

###### 6.3.2 wedge

###### 6.3.3 垃圾回收

#### 7 关于硬件的思考

在开发Dune时，我们发现VT-x是一个令人惊讶的灵活的硬件机制。特别是，VMCS提供的细粒度控制允许我们精确地指导硬件是如何暴露的。但是，对VT-x的一些硬件更改可能会有利于Dune。 一个值得注意的领域是EPT，因为我们遇到了性能开销和实施挑战。已经提出了硬件修改以减轻EPT开销。 此外，修改EPT以支持与常规页表相同的地址宽度将减少我们的实现的复杂性并且改进过程地址空间的覆盖。进一步减少VM退出和VM进入延迟也可以使Dune受益。但是，我们能够积极优化hypercalls，并且VMX转换成本对我们评估的应用程序的性能只有很小的影响。

有一些硬件功能，我们还没有暴露，尽管事实上，他们是可用的VT-X和可能支持。大多数似乎只在特殊情况下有用。 例如，用户程序可能想要控制缓存以防止信息泄漏。然而，这将仅在CPU亲和性可以被控制时才有效。 作为另一个例子，访问高效轮询指令（即MONITOR和MWAIT）可以用于降低执行高速缓存行轮询的用户空间消息传递实现的功耗。最后，暴露对调试寄存器的访问可以允许用户程序更有效地设置内存观察点。

提供可直接访问IO设备的Dune应用程序也很有用。许多VT-x系统包括对IOMMU的支持，即可用于使DMA访问安全的设备，即使其不可信软件可用。因此，可以修改Dune以安全地暴露某些硬件设备。 潜在的好处是减少IO延迟。 SR-IOV的可用性使这种可能性更实用，因为它允许单个物理设备在多个客户机之间进行分区。

#### 8 相关的工作

已经有多种努力使应用程序能够更好地访问硬件。例如，Exokernel通过低级内核接口显示硬件功能，允许应用程序直接管理硬件资源。SPIN项目采用的另一种方法是允许应用程序安全地将扩展直接加载到内核中。Dune与这些方法有许多相似之处，因为它也试图给应用程序更多的硬件访问。然而，Dune不同，因为它的目标不是可扩展性。相反，Dune提供对特权硬件特征的访问，使得它们可以与OS协同使用，而不是修改或重写它的手段。

Fluke项目在软件中支持嵌套过程模型，允许OS“垂直”构建。Dune补充了这种方法，因为它可以用于通过使用特权模式硬件在应用程序和内核之间有效地支持额外的操作系统层。但是，Dune公开的硬件只能支持单个级别，而不是Fluke中提供的多个级别。

已经采用广泛的策略来支持沙箱，例如ptrace，专用内核修改，二进制转换和二进制验证。据我们所知，Dune是第一个通过用户级访问硬件保护来支持沙盒的系统，提高性能并降低代码复杂性。例如，Native Client报告平均SPEC2000开销为5％，最坏情况下的性能为12％ - 我们观察到现代微架构的开销较高。相比之下，对于Dune中的相同基准，我们可以实现几乎为零的平均开销（最差情况为1.4％）。我们的沙箱与Native Client类似，因为它在进程中创建了一个安全的子域。但是，Native Client比Dune更portable，因为它不需要虚拟化硬件或内核更改。

像Dune，一些以前的工作使用硬件虚拟化为非传统目的。例如，已经建议VT-x作为用于创建难以检测的rootkit的工具。此外，IOMMU硬件已被用于通过在Linux进程中运行它们来安全隔离恶意设备驱动程序

#### 9.结论

Dune为普通应用程序提供了高效和安全地访问传统上只能用于内核的特权硬件功能。它通过利用现代虚拟化硬件来实现这一点，这使得能够在无特权的上下文中直接执行特权指令。我们对Linux的Dune的实现使用英特尔的VT-x虚拟化架构，并提供对异常，虚拟内存和权限模式的应用程序级访问。我们的评估显示了Dune的性能和安全性。例如，我们构建了一个接近零开销的沙箱，修改了一个垃圾回收器以将性能提高40.7％，并创建了一个特权分离系统，与没有Dune相比，减少了3倍的上下文切换开销。

为了促进采用，我们已经将Dune结构化为一个与未修改的Linux内核一起工作的模块。我们希望本文中描述的应用程序只是人们将为系统找到的许多用途中的第一个。Dune公开的硬件机制是许多操作系统创新的核心; 他们从用户级的新的可访问性创建了部署新的系统而没有内核修改的机会。



Dune为普通用户程序提供了安全有效的访问特权CPU的功能，这些特性通常只能用于内核。 它通过利用现代虚拟化硬件来实现，从而能够在无特权的环境中直接执行特权指令。 我们已经实现了Linux的Dune，使用英特尔的VT-x虚拟化架构来暴露对异常，虚拟内存，权限模式和分段的访问。 通过使这些硬件机制在用户级可用，Dune创建了部署新系统而不需要专门的内核修改的机制。

Dune旨在以安全的方式仅暴露特权CPU功能。 Dune内核模块确保进程只能访问通常在Linux下可用的相同内存。 此外，进程不能使用Dune访问外设或其他支持DMA的设备